"""
AUTOMATIC MODEL LOADER INTEGRATION
Generated by Automatic Model Update System
"""

import os
import json
import pickle
import logging
from typing import Dict, Any, Optional
from datetime import datetime

class ProductionModelLoader:
    """Load models được deploy tự động"""
    
    def __init__(self, config_file="model_deployment_config.json"):
        self.config_file = config_file
        self.loaded_models = {}
        self.model_config = self.load_config()
        
    def load_config(self) -> Dict:
        """Load model deployment configuration"""
        if os.path.exists(self.config_file):
            with open(self.config_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        return {}
    
    def get_active_models(self) -> Dict:
        """Get list of active models"""
        return self.model_config.get('active_models', {})
    
    def load_best_model(self) -> Optional[Any]:
        """Load model với performance tốt nhất"""
        active_models = self.get_active_models()
        
        if not active_models:
            return None
        
        # Find model with highest priority
        best_model_name = None
        best_priority = 0
        
        for model_name, model_info in active_models.items():
            priority = model_info.get('priority', 0)
            if priority > best_priority:
                best_priority = priority
                best_model_name = model_name
        
        if best_model_name:
            return self.load_model(best_model_name)
        
        return None
    
    def load_model(self, model_name: str) -> Optional[Any]:
        """Load specific model"""
        if model_name in self.loaded_models:
            return self.loaded_models[model_name]
        
        active_models = self.get_active_models()
        
        if model_name not in active_models:
            return None
        
        model_info = active_models[model_name]
        model_path = model_info['path']
        
        if not os.path.exists(model_path):
            return None
        
        try:
            with open(model_path, 'rb') as f:
                model = pickle.load(f)
            
            self.loaded_models[model_name] = model
            logging.info(f"Loaded production model: {model_name}")
            
            return model
            
        except Exception as e:
            logging.error(f"Error loading model {model_name}: {e}")
            return None
    
    def get_model_performance(self, model_name: str) -> Dict:
        """Get performance metrics của model"""
        active_models = self.get_active_models()
        
        if model_name in active_models:
            return active_models[model_name].get('performance', {})
        
        return {}
    
    def predict_with_best_model(self, X) -> Dict:
        """Predict sử dụng model tốt nhất"""
        model = self.load_best_model()
        
        if model is None:
            return {'prediction': 0.5, 'confidence': 0.0, 'model_used': None}
        
        try:
            if hasattr(model, 'predict_proba'):
                prediction_proba = model.predict_proba(X)
                prediction = prediction_proba[:, 1] if prediction_proba.shape[1] > 1 else prediction_proba[:, 0]
                confidence = max(prediction_proba[0])
            else:
                prediction = model.predict(X)
                confidence = 0.7  # Default confidence
            
            return {
                'prediction': float(prediction[0]) if hasattr(prediction, '__len__') else float(prediction),
                'confidence': float(confidence),
                'model_used': self.get_best_model_name(),
                'deployment_date': self.model_config.get('last_update'),
                'model_type': '100_epochs_intensive'
            }
            
        except Exception as e:
            logging.error(f"Prediction error: {e}")
            return {'prediction': 0.5, 'confidence': 0.0, 'model_used': None, 'error': str(e)}
    
    def get_best_model_name(self) -> Optional[str]:
        """Get tên của model tốt nhất"""
        active_models = self.get_active_models()
        
        if not active_models:
            return None
        
        best_model_name = None
        best_priority = 0
        
        for model_name, model_info in active_models.items():
            priority = model_info.get('priority', 0)
            if priority > best_priority:
                best_priority = priority
                best_model_name = model_name
        
        return best_model_name
    
    def check_for_model_updates(self) -> Dict:
        """Kiểm tra có models mới được train không"""
        try:
            # Check training results folder for new models
            training_results_dir = "training_results"
            if not os.path.exists(training_results_dir):
                return {"status": "no_training_folder", "updates_available": False}
            
            # Get latest training result
            result_files = [f for f in os.listdir(training_results_dir) if f.endswith('.json')]
            if not result_files:
                return {"status": "no_training_results", "updates_available": False}
            
            # Sort by date in filename
            result_files.sort(reverse=True)
            latest_result_file = result_files[0]
            
            # Check if this is newer than current deployment
            current_update = self.model_config.get('last_update', '2000-01-01T00:00:00')
            
            # Extract date from filename (assuming format: *_YYYYMMDD_HHMMSS.json)
            try:
                date_part = latest_result_file.split('_')[-2] + '_' + latest_result_file.split('_')[-1].replace('.json', '')
                latest_date = datetime.strptime(date_part, '%Y%m%d_%H%M%S')
                current_date = datetime.fromisoformat(current_update.replace('Z', '+00:00'))
                
                if latest_date > current_date:
                    return {
                        "status": "updates_available",
                        "updates_available": True,
                        "latest_training": latest_result_file,
                        "latest_date": latest_date.isoformat()
                    }
            except:
                pass
            
            return {"status": "up_to_date", "updates_available": False}
            
        except Exception as e:
            logging.error(f"Error checking for model updates: {e}")
            return {"status": "error", "updates_available": False, "error": str(e)}
    
    def auto_update_models(self) -> Dict:
        """Tự động update models từ training results mới nhất"""
        try:
            update_check = self.check_for_model_updates()
            
            if not update_check.get("updates_available", False):
                return {"status": "no_updates", "updated": False}
            
            # TODO: Implement actual model update logic
            # This would involve:
            # 1. Loading new training results
            # 2. Evaluating model performance
            # 3. Updating deployment config
            # 4. Reloading models
            
            return {
                "status": "update_pending",
                "updated": False,
                "message": "Auto-update logic needs implementation"
            }
            
        except Exception as e:
            logging.error(f"Auto-update error: {e}")
            return {"status": "error", "updated": False, "error": str(e)}
    
    def get_system_status(self) -> Dict:
        """Get comprehensive status của production models system"""
        try:
            active_models = self.get_active_models()
            best_model_name = self.get_best_model_name()
            update_check = self.check_for_model_updates()
            
            return {
                "timestamp": datetime.now().isoformat(),
                "total_models": len(active_models),
                "best_model": best_model_name,
                "models_loaded": len(self.loaded_models),
                "last_deployment": self.model_config.get('last_update'),
                "deployment_type": self.model_config.get('deployment_type'),
                "update_status": update_check,
                "model_details": {
                    name: {
                        "performance": info.get('performance', {}),
                        "priority": info.get('priority', 0),
                        "type": info.get('type')
                    }
                    for name, info in active_models.items()
                }
            }
            
        except Exception as e:
            return {"error": str(e), "timestamp": datetime.now().isoformat()}

# Global instance for easy import
production_model_loader = ProductionModelLoader()
